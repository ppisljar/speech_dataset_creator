<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Podcast Management System</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        input, select {
            padding: 8px;
            margin: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .file-list, .project-list {
            margin: 10px 0;
        }
        .item {
            padding: 5px;
            margin: 2px 0;
            background-color: #f8f9fa;
            border-radius: 3px;
        }
        .error {
            color: red;
            margin: 10px 0;
        }
        .success {
            color: green;
            margin: 10px 0;
        }
        .project-header {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .project-header h2 {
            margin: 0;
            margin-right: 20px;
        }
        .project-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }
        .project-controls select {
            min-width: 200px;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            border-radius: 8px;
            width: 400px;
            max-width: 90%;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover {
            color: black;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input {
            width: 100%;
            box-sizing: border-box;
        }
        .button-group {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Podcast Management System</h1>
        
        <!-- Project Header with unified controls -->
        <div class="project-header">
            <h2>Project:</h2>
            <div class="project-controls">
                <select id="globalProjectSelect">
                    <option value="">Select Project</option>
                </select>
                <button onclick="showAddProjectModal()">Add</button>
                <button onclick="deleteSelectedProject()" id="deleteProjectBtn" disabled>Delete</button>
                <button onclick="showEditProjectModal()" id="editProjectBtn" disabled>Edit</button>
                <div>
                    <input type="file" id="fileUpload">
                    <button onclick="uploadFile()">Upload File</button>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Data Viewer</h2>
            <div>
                <select id="dataFileSelect">
                    <option value="">Select File</option>
                </select>
                <select id="dataSplitSelect">
                    <option value="">Select Split</option>
                </select>
                <button onclick="loadData()">Load Data</button>
                <button onclick="refreshFile()">Refresh File</button>
                <div style="margin: 10px 0;">
                    Zoom: 
                    <button onclick="setZoom(1000)">1s/px</button>
                    <button onclick="setZoom(100)">100ms/px</button>
                    <button onclick="setZoom(50)">50ms/px</button>
                    <button onclick="setZoom(10)">10ms/px</button>
                    <span id="currentZoom" style="margin-left: 10px;"></span>
                </div>
            </div>
            
            <!-- Waveform Viewer -->
            <div id="waveformContainer" style="display: none; width: 100%; margin: 20px 0;">
                <div style="position: relative; width: 100%; height: 500px; border: 1px solid #ddd; background: #fff;">
                    <canvas id="waveformCanvas" width="1200" height="500" style="position: absolute; top: 0; left: 0; cursor: crosshair;"></canvas>
                    <canvas id="annotationsCanvas" width="1200" height="500" style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
                </div>
                
                <!-- Audio Controls -->
                <div style="margin: 10px 0; display: flex; align-items: center; gap: 10px;">
                    <button id="playBtn" onclick="playAudio()" disabled>Play</button>
                    <button id="pauseBtn" onclick="pauseAudio()" disabled>Pause</button>
                    <button id="stopBtn" onclick="stopAudio()" disabled>Stop</button>
                    <span id="audioTime" style="margin-left: 10px; font-family: monospace;">0:00 / 0:00</span>
                    <span id="volumeControl" style="margin-left: 20px;">
                        Volume: <input type="range" id="volumeSlider" min="0" max="100" value="50" style="width: 100px;">
                    </span>
                </div>
                
                <!-- Timeline Slider -->
                <div style="margin: 10px 0;">
                    <input type="range" id="timelineSlider" min="0" max="100" value="0" style="width: 100%;">
                    <div style="display: flex; justify-content: space-between; font-size: 12px; margin-top: 5px;">
                        <span id="startTime">0:00</span>
                        <span>Position: <span id="currentPosition">0:00</span></span>
                        <span id="endTime">0:00</span>
                    </div>
                </div>
                
                <!-- Legend -->
                <div style="margin: 10px 0; display: flex; gap: 20px; font-size: 12px;">
                    <div><span style="border: 2px solid blue; padding: 2px 8px;">Silences</span></div>
                    <div><span style="border: 2px solid green; padding: 2px 8px;">Pyannote</span></div>
                    <div><span style="border: 2px solid red; padding: 2px 8px;">Segments</span></div>
                    <div><span style="border: 2px solid purple; padding: 2px 8px;">Subsegments</span></div>
                    <div><span style="border: 2px solid orange; padding: 2px 8px;">Transcriptions</span></div>
                </div>
            </div>
            
            <div id="dataViewer" style="background-color: #f8f9fa; padding: 10px; margin: 10px 0; min-height: 100px; overflow: auto;">
                <!-- display the table of segments here -->
            </div>
        </div>

        <div class="section">
            <h2>Processing Status</h2>
            <div>
                <button onclick="loadProcessingStatus()">Refresh Status</button>
            </div>
            <div id="processingStatus" style="background-color: #f8f9fa; padding: 10px; margin: 10px 0; min-height: 100px; overflow: auto;"></div>
        </div>

        <div id="messages"></div>
    </div>

    <!-- Add Project Modal -->
    <div id="addProjectModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Add New Project</h3>
                <span class="close" onclick="closeModal('addProjectModal')">&times;</span>
            </div>
            <div class="form-group">
                <label for="modalProjectName">Project Name:</label>
                <input type="text" id="modalProjectName" placeholder="Enter project name">
            </div>
            <div class="form-group">
                <label for="modalSilenceThreshold">Silence Threshold (dB):</label>
                <input type="number" id="modalSilenceThreshold" value="-40" step="1" min="-100" max="0">
            </div>
            <div class="form-group">
                <label for="modalMinSilenceLength">Minimum Silence Length (ms):</label>
                <input type="number" id="modalMinSilenceLength" value="500" step="100" min="100">
            </div>
            <div class="button-group">
                <button onclick="closeModal('addProjectModal')">Cancel</button>
                <button onclick="createProjectWithSettings()">Create Project</button>
            </div>
        </div>
    </div>

    <!-- Edit Project Modal -->
    <div id="editProjectModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Edit Project</h3>
                <span class="close" onclick="closeModal('editProjectModal')">&times;</span>
            </div>
            <div class="form-group">
                <label for="editProjectName">Project Name:</label>
                <input type="text" id="editProjectName" placeholder="Enter project name">
            </div>
            <div class="form-group">
                <label for="editSilenceThreshold">Silence Threshold (dB):</label>
                <input type="number" id="editSilenceThreshold" value="-40" step="1" min="-100" max="0">
            </div>
            <div class="form-group">
                <label for="editMinSilenceLength">Minimum Silence Length (ms):</label>
                <input type="number" id="editMinSilenceLength" value="500" step="100" min="100">
            </div>
            <div class="button-group">
                <button onclick="closeModal('editProjectModal')">Cancel</button>
                <button onclick="updateProjectWithSettings()">Update Project</button>
            </div>
        </div>
    </div>

    <script>
        // Load projects on page load
        window.onload = function() {
            loadProjects();
            loadProcessingStatus();
        };

        // Global project variable
        let currentProject = null;

        function showMessage(message, isError = false) {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = isError ? 'error' : 'success';
            messageDiv.textContent = message;
            messagesDiv.appendChild(messageDiv);
            setTimeout(() => messageDiv.remove(), 5000);
        }

        async function loadProjects() {
            try {
                const response = await fetch('/api/projects');
                const projects = await response.json();
                
                const globalProjectSelect = document.getElementById('globalProjectSelect');
                
                // Store current selection
                const currentSelection = globalProjectSelect.value;
                
                globalProjectSelect.innerHTML = '<option value="">Select Project</option>';
                
                projects.forEach(project => {
                    const option = document.createElement('option');
                    option.value = project;
                    option.textContent = project;
                    globalProjectSelect.appendChild(option);
                });
                
                // Restore selection if it still exists
                if (currentSelection && projects.includes(currentSelection)) {
                    globalProjectSelect.value = currentSelection;
                    currentProject = currentSelection;
                } else {
                    currentProject = null;
                }
                
                updateProjectButtons();

                // Add event listener to global project select
                document.getElementById('globalProjectSelect').addEventListener('change', async function() {
                    currentProject = this.value;
                    updateProjectButtons();
                    
                    // Reset dependent dropdowns
                    // const fileSelect = document.getElementById('fileSelect');
                    // const splitSelect = document.getElementById('splitSelect');
                    const dataFileSelect = document.getElementById('dataFileSelect');
                    const dataSplitSelect = document.getElementById('dataSplitSelect');
                    
                    // fileSelect.innerHTML = '<option value="">Select File</option>';
                    // splitSelect.innerHTML = '<option value="">Select Split</option>';
                    dataFileSelect.innerHTML = '<option value="">Select File</option>';
                    dataSplitSelect.innerHTML = '<option value="">Select Split</option>';
                    
                    if (!currentProject) return;

                    try {
                        const response = await fetch(`/api/projects/${currentProject}/files/raw`);
                        const files = await response.json();
                        
                        if (response.ok) {
                            files.forEach(file => {
                                // const option1 = document.createElement('option');
                                // option1.value = file;
                                // option1.textContent = file;
                                // fileSelect.appendChild(option1);
                                
                                const option2 = document.createElement('option');
                                option2.value = file;
                                option2.textContent = file;
                                dataFileSelect.appendChild(option2);
                            });
                        } else {
                            showMessage('Error loading files: ' + files.error, true);
                        }
                    } catch (error) {
                        showMessage('Error loading files: ' + error.message, true);
                    }
                });

                // Add event listener to fileSelect
                // document.getElementById('fileSelect').addEventListener('change', async function() {
                //     const filename = this.value;
                //     const splitSelect = document.getElementById('splitSelect');
                    
                //     // Reset splits dropdown
                //     splitSelect.innerHTML = '<option value="">Select Split</option>';
                    
                //     if (!currentProject || !filename) return;

                //     try {
                //         const response = await fetch(`/api/projects/${currentProject}/splits/${filename}`);
                //         const splits = await response.json();
                        
                //         if (response.ok) {
                //             splits.forEach(split => {
                //                 const option = document.createElement('option');
                //                 option.value = split;
                //                 option.textContent = split;
                //                 splitSelect.appendChild(option);
                //             });
                //         } else {
                //             showMessage('Error loading splits: ' + splits.error, true);
                //         }
                //     } catch (error) {
                //         showMessage('Error loading splits: ' + error.message, true);
                //     }
                // });

                // Add event listener to dataFileSelect
                document.getElementById('dataFileSelect').addEventListener('change', async function() {
                    const filename = this.value;
                    const dataSplitSelect = document.getElementById('dataSplitSelect');
                    
                    // Reset splits dropdown
                    dataSplitSelect.innerHTML = '<option value="">Select Split</option>';
                    
                    if (!currentProject || !filename) return;

                    try {
                        const response = await fetch(`/api/projects/${currentProject}/splits/${filename}`);
                        const splits = await response.json();
                        
                        if (response.ok) {
                            splits.forEach(split => {
                                const option = document.createElement('option');
                                option.value = split;
                                option.textContent = split;
                                dataSplitSelect.appendChild(option);
                            });
                        } else {
                            showMessage('Error loading splits: ' + splits.error, true);
                        }
                    } catch (error) {
                        showMessage('Error loading splits: ' + error.message, true);
                    }
                });

            } catch (error) {
                showMessage('Error loading projects: ' + error.message, true);
            }
        }

        function updateProjectButtons() {
            const deleteBtn = document.getElementById('deleteProjectBtn');
            const editBtn = document.getElementById('editProjectBtn');
            
            if (currentProject) {
                deleteBtn.disabled = false;
                editBtn.disabled = false;
            } else {
                deleteBtn.disabled = true;
                editBtn.disabled = true;
            }
        }

        // Modal functions
        function showAddProjectModal() {
            document.getElementById('modalProjectName').value = '';
            document.getElementById('modalSilenceThreshold').value = '-40';
            document.getElementById('modalMinSilenceLength').value = '500';
            document.getElementById('addProjectModal').style.display = 'block';
        }

        async function showEditProjectModal() {
            if (!currentProject) {
                showMessage('Please select a project to edit', true);
                return;
            }
            
            document.getElementById('editProjectName').value = currentProject;
            
            try {
                // Load existing project settings
                const response = await fetch(`/api/projects/${currentProject}/settings`);
                const settings = await response.json();
                
                if (response.ok) {
                    document.getElementById('editSilenceThreshold').value = settings.silenceThreshold || -40;
                    document.getElementById('editMinSilenceLength').value = settings.minSilenceLength || 500;
                } else {
                    // Use defaults if settings not found
                    document.getElementById('editSilenceThreshold').value = '-40';
                    document.getElementById('editMinSilenceLength').value = '500';
                }
            } catch (error) {
                // Use defaults if error loading settings
                document.getElementById('editSilenceThreshold').value = '-40';
                document.getElementById('editMinSilenceLength').value = '500';
                showMessage('Could not load project settings, using defaults', true);
            }
            
            document.getElementById('editProjectModal').style.display = 'block';
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // Close modal when clicking outside of it
        window.onclick = function(event) {
            const addModal = document.getElementById('addProjectModal');
            const editModal = document.getElementById('editProjectModal');
            if (event.target == addModal) {
                addModal.style.display = 'none';
            }
            if (event.target == editModal) {
                editModal.style.display = 'none';
            }
        }

        async function createProjectWithSettings() {
            const name = document.getElementById('modalProjectName').value.trim();
            const silenceThreshold = document.getElementById('modalSilenceThreshold').value;
            const minSilenceLength = document.getElementById('modalMinSilenceLength').value;
            
            if (!name) {
                showMessage('Please enter a project name', true);
                return;
            }

            try {
                const response = await fetch('/api/projects', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        name: name,
                        settings: {
                            silenceThreshold: parseFloat(silenceThreshold),
                            minSilenceLength: parseInt(minSilenceLength)
                        }
                    })
                });

                const result = await response.json();
                if (response.ok) {
                    showMessage(result.message);
                    closeModal('addProjectModal');
                    await loadProjects();
                    // Select the newly created project
                    document.getElementById('globalProjectSelect').value = name;
                    currentProject = name;
                    updateProjectButtons();
                } else {
                    showMessage(result.error, true);
                }
            } catch (error) {
                showMessage('Error creating project: ' + error.message, true);
            }
        }

        async function updateProjectWithSettings() {
            const oldName = currentProject;
            const newName = document.getElementById('editProjectName').value.trim();
            const silenceThreshold = document.getElementById('editSilenceThreshold').value;
            const minSilenceLength = document.getElementById('editMinSilenceLength').value;
            
            if (!newName) {
                showMessage('Please enter a project name', true);
                return;
            }

            try {
                const response = await fetch(`/api/projects/${oldName}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        name: newName,
                        settings: {
                            silenceThreshold: parseFloat(silenceThreshold),
                            minSilenceLength: parseInt(minSilenceLength)
                        }
                    })
                });

                const result = await response.json();
                if (response.ok) {
                    showMessage(result.message);
                    closeModal('editProjectModal');
                    await loadProjects();
                    // Select the updated project
                    document.getElementById('globalProjectSelect').value = newName;
                    currentProject = newName;
                    updateProjectButtons();
                } else {
                    showMessage(result.error, true);
                }
            } catch (error) {
                showMessage('Error updating project: ' + error.message, true);
            }
        }

        async function deleteSelectedProject() {
            if (!currentProject) {
                showMessage('Please select a project to delete', true);
                return;
            }

            if (!confirm(`Are you sure you want to delete project "${currentProject}"?`)) {
                return;
            }

            try {
                const response = await fetch(`/api/projects/${currentProject}`, {
                    method: 'DELETE'
                });

                const result = await response.json();
                if (response.ok) {
                    showMessage(result.message);
                    currentProject = null;
                    await loadProjects();
                } else {
                    showMessage(result.error, true);
                }
            } catch (error) {
                showMessage('Error deleting project: ' + error.message, true);
            }
        }

        async function createProject() {
            const name = document.getElementById('newProjectName').value;
            if (!name) {
                showMessage('Please enter a project name', true);
                return;
            }

            try {
                const response = await fetch('/api/projects', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ name: name })
                });

                const result = await response.json();
                if (response.ok) {
                    showMessage(result.message);
                    document.getElementById('newProjectName').value = '';
                    loadProjects();
                } else {
                    showMessage(result.error, true);
                }
            } catch (error) {
                showMessage('Error creating project: ' + error.message, true);
            }
        }

        async function deleteProject(projectName) {
            if (!confirm(`Are you sure you want to delete project "${projectName}"?`)) {
                return;
            }

            try {
                const response = await fetch(`/api/projects/${projectName}`, {
                    method: 'DELETE'
                });

                const result = await response.json();
                if (response.ok) {
                    showMessage(result.message);
                    loadProjects();
                } else {
                    showMessage(result.error, true);
                }
            } catch (error) {
                showMessage('Error deleting project: ' + error.message, true);
            }
        }

        async function loadFiles() {
            const project = currentProject;
            const filename = document.getElementById('fileSelect').value;
            const splitname = document.getElementById('splitSelect').value;
            
            if (!project) {
                showMessage('Please select a project', true);
                return;
            }

            if (!filename) {
                showMessage('Please select a file', true);
                return;
            }

            if (!splitname) {
                showMessage('Please select a split', true);
                return;
            }

            try {
                // Load the split file and its associated annotation files
                const response = await fetch(`/api/projects/${project}/files/splits`);
                const splits = await response.json();
                
                const filesList = document.getElementById('filesList');
                filesList.innerHTML = '';
                
                if (response.ok) {
                    // Filter to show only files related to the selected split
                    const relatedFiles = splits.filter(split => split.startsWith(splitname.replace(/\.[^/.]+$/, "")));
                    
                    relatedFiles.forEach(file => {
                        const fileDiv = document.createElement('div');
                        fileDiv.className = 'item';
                        fileDiv.innerHTML = `
                            <span>${file}</span>
                            <button onclick="deleteFile('${project}', 'splits', '${file}')">Delete</button>
                        `;
                        filesList.appendChild(fileDiv);
                    });

                    if (relatedFiles.length === 0) {
                        filesList.innerHTML = '<div class="item">No related files found for this split</div>';
                    }
                } else {
                    showMessage('Error loading split files: ' + splits.error, true);
                }
            } catch (error) {
                showMessage('Error loading files: ' + error.message, true);
            }
        }

        async function uploadFile() {
            const project = currentProject;
            const filetype = document.getElementById('filetypeSelect').value;
            const fileInput = document.getElementById('fileUpload');
            
            if (!project) {
                showMessage('Please select a project', true);
                return;
            }
            
            if (!fileInput.files[0]) {
                showMessage('Please select a file', true);
                return;
            }

            try {
                const formData = new FormData();
                formData.append('file', fileInput.files[0]);

                const response = await fetch(`/api/projects/${project}/files/${filetype}`, {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                if (response.ok) {
                    showMessage(result.message);
                    fileInput.value = '';
                    loadFiles();
                } else {
                    showMessage(result.error, true);
                }
            } catch (error) {
                showMessage('Error uploading file: ' + error.message, true);
            }
        }

        async function deleteFile(project, filetype, filename) {
            if (!confirm(`Are you sure you want to delete "${filename}"?`)) {
                return;
            }

            try {
                const response = await fetch(`/api/projects/${project}/files/${filetype}/${filename}`, {
                    method: 'DELETE'
                });

                const result = await response.json();
                if (response.ok) {
                    showMessage(result.message);
                    loadFiles();
                } else {
                    showMessage(result.error, true);
                }
            } catch (error) {
                showMessage('Error deleting file: ' + error.message, true);
            }
        }

        // Waveform viewer state
        let waveformData = {
            audioData: null,
            audioBuffer: null,
            silences: [],
            transcriptions: [],
            pyannote: [],
            segments: [],
            duration: 0,
            sampleRate: 44100,
            zoom: 1000, // milliseconds per pixel
            viewStart: 0, // start time in seconds
            canvasWidth: 1200,
            mouseX: -1 // Mouse X position for hover indicator
        };

        // Audio context for decoding audio files
        let audioContext = null;
        let audioSource = null;
        let isPlaying = false;
        let playStartTime = 0;
        let audioStartOffset = 0;
        let animationId = null;

        async function loadData() {
            const project = currentProject;
            const filename = document.getElementById('dataFileSelect').value;
            const splitname = document.getElementById('dataSplitSelect').value;
            
            if (!project) {
                showMessage('Please select a project', true);
                return;
            }
            
            if (!filename) {
                showMessage('Please select a file', true);
                return;
            }

            if (!splitname) {
                showMessage('Please select a split', true);
                return;
            }

            try {
                showMessage('Loading audio data and annotations...');
                
                // Load all data types using the selected split name
                const [silencesRes, transcriptionsRes, pyannoteRes, segmentsRes, audioRes] = await Promise.all([
                    fetch(`/api/projects/${project}/splits/${filename}/${splitname}_silences.json`).catch(() => ({ok: false})),
                    fetch(`/api/projects/${project}/splits/${filename}/${splitname}_transcription.json`).catch(() => ({ok: false})),
                    fetch(`/api/projects/${project}/splits/${filename}/${splitname}_pyannote.csv`).catch(() => ({ok: false})),
                    fetch(`/api/projects/${project}/splits/${filename}/${splitname}_segments.json`).catch(() => ({ok: false})),
                    fetch(`/api/projects/${project}/splits/${filename}/${splitname}`).catch(() => ({ok: false}))
                ]);

                // Parse responses
                if (silencesRes.ok) {
                    const rawSilences = await silencesRes.json();
                    // Convert array of [start, end] arrays to objects with start/end properties
                    // Times are in milliseconds, convert to seconds for consistency
                    waveformData.silences = rawSilences.map(silence => ({
                        start: silence[0] / 1000, // Convert ms to seconds
                        end: silence[1] / 1000     // Convert ms to seconds
                    }));
                }
                if (transcriptionsRes.ok) {
                    const rawTranscriptions = await transcriptionsRes.json();
                    // Convert transcription tokens to expected format
                    // Times are in milliseconds, convert to seconds for consistency
                    if (rawTranscriptions.tokens) {
                        waveformData.transcriptions = rawTranscriptions.tokens.map(token => ({
                            start: token.start_ms / 1000, // Convert ms to seconds
                            end: token.end_ms / 1000,     // Convert ms to seconds
                            speaker: token.speaker,
                            text: token.text,
                            confidence: token.confidence
                        }));
                    } else {
                        waveformData.transcriptions = [];
                    }
                }
                if (pyannoteRes.ok) {
                    const pyannoteText = await pyannoteRes.text();
                    waveformData.pyannote = parsePyannoteCSV(pyannoteText);
                }
                if (segmentsRes.ok) {
                    const rawSegments = await segmentsRes.json();
                    // Convert segments to expected format
                    // Times are in milliseconds, convert to seconds for consistency
                    if (rawSegments.segments) {
                        waveformData.segments = rawSegments.segments.map(segment => ({
                            start: segment.main.start_ms / 1000, // Convert ms to seconds
                            end: segment.main.end_ms / 1000,     // Convert ms to seconds
                            speaker: segment.main.speaker,
                            text: segment.main.text,
                            confidence: segment.main.min_conf,
                            seg_idx: segment.seg_idx,
                            // Also include subsegments for detailed view
                            subs: segment.subs.map(sub => ({
                                start: sub.start_ms / 1000,
                                end: sub.end_ms / 1000,
                                speaker: sub.speaker,
                                text: sub.text,
                                confidence: sub.min_conf
                            }))
                        }));
                    } else {
                        waveformData.segments = [];
                    }
                }

                // Load and decode actual audio data
                if (audioRes.ok) {
                    const audioBlob = await audioRes.blob();
                    await decodeAudioData(audioBlob);
                } else {
                    // Fallback: estimate duration from annotations and create placeholder
                    estimateDurationFromAnnotations();
                    await generatePlaceholderWaveform(waveformData.duration * 44100);
                }

                // Show waveform container and initialize
                document.getElementById('waveformContainer').style.display = 'block';
                initializeWaveformViewer();
                drawWaveform();
                
                // Display segments table in data viewer
                displaySegmentsTable();
                
                showMessage('Audio data loaded successfully!');
                
            } catch (error) {
                showMessage('Error loading data: ' + error.message, true);
            }
        }

        function parsePyannoteCSV(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim());
            return lines.slice(1).map(line => { // Skip header
                const parts = line.split(',');
                return {
                    speaker: parts[0] || 'unknown',
                    start: parseFloat(parts[1]),
                    end: parseFloat(parts[2])
                };
            }).filter(item => !isNaN(item.start) && !isNaN(item.end));
        }

        async function initializeAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            // Resume context if suspended (required by some browsers)
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }
        }

        async function decodeAudioData(audioBlob) {
            try {
                await initializeAudioContext();
                
                const arrayBuffer = await audioBlob.arrayBuffer();
                waveformData.audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // Extract mono channel data for visualization
                const channelData = waveformData.audioBuffer.getChannelData(0);
                waveformData.duration = waveformData.audioBuffer.duration;
                waveformData.sampleRate = waveformData.audioBuffer.sampleRate;
                
                // Downsample for visualization (1 sample per 10ms = 100 samples per second)
                const targetSampleRate = 100; // samples per second for visualization
                const downsampleRatio = waveformData.sampleRate / targetSampleRate;
                const outputLength = Math.floor(channelData.length / downsampleRatio);
                
                waveformData.audioData = new Float32Array(outputLength);
                
                // Downsample using RMS for better visualization
                for (let i = 0; i < outputLength; i++) {
                    const start = Math.floor(i * downsampleRatio);
                    const end = Math.min(start + downsampleRatio, channelData.length);
                    
                    let sum = 0;
                    let count = 0;
                    for (let j = start; j < end; j++) {
                        sum += channelData[j] * channelData[j];
                        count++;
                    }
                    
                    // RMS value for better amplitude representation
                    waveformData.audioData[i] = Math.sqrt(sum / count) * Math.sign(channelData[Math.floor((start + end) / 2)]);
                }
                
                console.log(`Decoded audio: ${waveformData.duration.toFixed(2)}s, ${waveformData.sampleRate}Hz, ${outputLength} visualization samples`);
                
                // Enable audio controls
                document.getElementById('playBtn').disabled = false;
                document.getElementById('stopBtn').disabled = false;
                
            } catch (error) {
                console.error('Error decoding audio:', error);
                showMessage('Failed to decode audio file. Using placeholder waveform.', true);
                await generatePlaceholderWaveform(waveformData.duration * 44100);
            }
        }

        async function generatePlaceholderWaveform(estimatedSamples) {
            // Generate a placeholder waveform when audio decoding fails
            const duration = estimatedSamples / waveformData.sampleRate;
            waveformData.duration = duration;
            waveformData.audioData = new Float32Array(Math.floor(duration * 100)); // 100 samples per second for visualization
            
            for (let i = 0; i < waveformData.audioData.length; i++) {
                // Create a more subtle placeholder pattern
                const t = i / 100;
                waveformData.audioData[i] = 
                    (Math.sin(t * 2 * Math.PI * 0.5) * 0.1 + // Slow sine wave
                     (Math.random() - 0.5) * 0.05) *        // Light noise
                    Math.exp(-t * 0.01);                     // Very slow decay
            }
            
            console.log(`Generated placeholder waveform: ${duration.toFixed(2)}s`);
        }

        function estimateDurationFromAnnotations() {
            let maxTime = 0;
            
            // Check all annotation types for maximum time
            [...waveformData.silences, ...waveformData.transcriptions, 
             ...waveformData.pyannote, ...waveformData.segments].forEach(item => {
                if (item.end && item.end > maxTime) maxTime = item.end;
                if (item.start && item.start > maxTime) maxTime = item.start;
            });
            
            waveformData.duration = Math.max(maxTime, 60); // At least 1 minute
        }

        function initializeWaveformViewer() {
            const canvas = document.getElementById('waveformCanvas');
            const container = canvas.parentElement;
            
            // Set canvas size to container width
            waveformData.canvasWidth = container.clientWidth;
            canvas.width = waveformData.canvasWidth;
            canvas.height = 480;
            document.getElementById('annotationsCanvas').width = waveformData.canvasWidth;
            document.getElementById('annotationsCanvas').height = 480;
            
            // Initialize timeline slider
            const slider = document.getElementById('timelineSlider');
            slider.addEventListener('input', function() {
                const progress = parseFloat(this.value) / 100;
                const viewDuration = (waveformData.canvasWidth * waveformData.zoom) / 1000;
                waveformData.viewStart = progress * Math.max(0, waveformData.duration - viewDuration);
                drawWaveform();
                updateTimeDisplay();
            });
            
            // Add canvas click handler for seeking
            canvas.addEventListener('click', function(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const viewDuration = (waveformData.canvasWidth * waveformData.zoom) / 1000;
                const timeOffset = (x / waveformData.canvasWidth) * viewDuration;
                const newTime = waveformData.viewStart + timeOffset;
                
                if (newTime >= 0 && newTime <= waveformData.duration) {
                    seekToTime(newTime);
                    showMessage(`Seeked to time: ${formatTime(newTime)}`);
                }
            });
            
            // Add mouse move handler for hover indicator
            canvas.addEventListener('mousemove', function(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                
                if (x >= 0 && x <= waveformData.canvasWidth) {
                    waveformData.mouseX = x;
                    drawWaveform(); // Redraw to show hover line
                } else {
                    waveformData.mouseX = -1;
                    drawWaveform();
                }
            });
            
            // Add mouse leave handler to hide hover indicator
            canvas.addEventListener('mouseleave', function(e) {
                waveformData.mouseX = -1;
                drawWaveform(); // Redraw to hide hover line
            });
            
            // Add volume control listener
            document.getElementById('volumeSlider').addEventListener('input', function() {
                if (audioSource && isPlaying) {
                    // Note: We can't change gain of an already playing source
                    // Volume will take effect on next play
                }
            });
            
            updateTimeDisplay();
            setZoom(waveformData.zoom);
        }

        function setZoom(millisecondsPerPixel) {
            waveformData.zoom = millisecondsPerPixel;
            document.getElementById('currentZoom').textContent = `(${millisecondsPerPixel}ms/px)`;
            drawWaveform();
            updateTimeDisplay();
        }

        function drawWaveform() {
            const canvas = document.getElementById('waveformCanvas');
            const annotationsCanvas = document.getElementById('annotationsCanvas');
            const ctx = canvas.getContext('2d');
            const annotationsCtx = annotationsCanvas.getContext('2d');
            
            // Clear canvases
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            annotationsCtx.clearRect(0, 0, annotationsCanvas.width, annotationsCanvas.height);
            
            if (!waveformData.audioData) return;
            
            // Calculate visible time range
            const viewDuration = (waveformData.canvasWidth * waveformData.zoom) / 1000; // in seconds
            const viewEnd = waveformData.viewStart + viewDuration;
            
            // Draw waveform (use only top 400px, leave bottom 80px for annotation tracks)
            const waveformHeight = 400;
            const centerY = waveformHeight / 2;
            
            // Draw waveform as filled areas for better visualization
            ctx.fillStyle = '#4A90E2';
            ctx.strokeStyle = '#2E5F8A';
            ctx.lineWidth = 1;
            
            // Calculate how many audio samples we need to average per pixel
            const samplesPerPixel = (viewDuration * 100) / waveformData.canvasWidth; // audioData is 100 samples/sec
            
            for (let x = 0; x < waveformData.canvasWidth; x++) {
                const timeAtPixel = waveformData.viewStart + (x / waveformData.canvasWidth) * viewDuration;
                const startSample = Math.floor(timeAtPixel * 100);
                const endSample = Math.floor((timeAtPixel + viewDuration / waveformData.canvasWidth) * 100);
                
                // Calculate min/max for this pixel to show amplitude range
                let minAmp = 0, maxAmp = 0;
                let sampleCount = 0;
                
                for (let i = startSample; i <= endSample && i < waveformData.audioData.length; i++) {
                    if (i >= 0) {
                        const amp = waveformData.audioData[i];
                        minAmp = Math.min(minAmp, amp);
                        maxAmp = Math.max(maxAmp, amp);
                        sampleCount++;
                    }
                }
                
                if (sampleCount > 0) {
                    // Scale amplitude to fit in waveform area
                    const scale = (waveformHeight * 0.4); // Use 80% of available height
                    const minY = centerY - (minAmp * scale);
                    const maxY = centerY - (maxAmp * scale);
                    
                    // Draw vertical line from min to max amplitude
                    if (Math.abs(maxY - minY) > 1) {
                        ctx.beginPath();
                        ctx.moveTo(x, minY);
                        ctx.lineTo(x, maxY);
                        ctx.stroke();
                    } else {
                        // For very quiet sections, draw a thin line
                        ctx.fillRect(x, centerY - 0.5, 1, 1);
                    }
                }
            }
            
            // Draw center line
            ctx.strokeStyle = '#E0E0E0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(waveformData.canvasWidth, centerY);
            ctx.stroke();
            
            // Draw current playback position (full height)
            const currentTime = getCurrentPlaybackTime();
            if (currentTime >= waveformData.viewStart && currentTime <= viewEnd) {
                const positionX = ((currentTime - waveformData.viewStart) / viewDuration) * waveformData.canvasWidth;
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(positionX, 0);
                ctx.lineTo(positionX, canvas.height); // Full canvas height
                ctx.stroke();
                
                // Draw playhead indicator at top
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.moveTo(positionX - 5, 0);
                ctx.lineTo(positionX + 5, 0);
                ctx.lineTo(positionX, 10);
                ctx.closePath();
                ctx.fill();
            }
            
            // Draw mouse hover indicator (full height, dashed line)
            if (waveformData.mouseX >= 0) {
                ctx.strokeStyle = '#888888';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]); // Dashed line pattern
                ctx.beginPath();
                ctx.moveTo(waveformData.mouseX, 0);
                ctx.lineTo(waveformData.mouseX, canvas.height); // Full canvas height
                ctx.stroke();
                ctx.setLineDash([]); // Reset line dash
            }
            
            // Draw annotations
            drawAnnotations(annotationsCtx, viewDuration);
        }

        function drawAnnotations(ctx, viewDuration) {
            const canvasHeight = ctx.canvas.height;
            const waveformHeight = 400;
            const trackHeight = 20;
            const viewEnd = waveformData.viewStart + viewDuration;
            
            // Helper function to convert time to x coordinate (supports times outside view)
            const timeToX = (time) => {
                return ((time - waveformData.viewStart) / viewDuration) * waveformData.canvasWidth;
            };
            
            // Helper function to check if an annotation overlaps with the current view
            const overlapsView = (startTime, endTime) => {
                return startTime < viewEnd && endTime > waveformData.viewStart;
            };
            
            // Define track positions (Y coordinates for each annotation type)
            const tracks = {
                silences: waveformHeight - 20,      // First track: 380-400px
                pyannote: waveformHeight,           // Second track: 400-420px  
                segments: waveformHeight + 20,      // Third track: 420-440px
                subsegments: waveformHeight + 40,   // Fourth track: 440-460px
                transcriptions: waveformHeight + 60 // Fifth track: 460-480px
            };
            
            // Draw track labels on the left
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#333';
            ctx.fillText('Silences', 2, tracks.silences + 14);
            ctx.fillText('Pyannote', 2, tracks.pyannote + 14);
            ctx.fillText('Segments', 2, tracks.segments + 14);
            ctx.fillText('Subsegments', 2, tracks.subsegments + 14);
            ctx.fillText('Transcriptions', 2, tracks.transcriptions + 14);
            
            // Draw silences (blue boxes) in first track
            ctx.strokeStyle = 'blue';
            ctx.fillStyle = 'rgba(0, 0, 255, 0.3)';
            ctx.lineWidth = 1;
            waveformData.silences.forEach(silence => {
                if (overlapsView(silence.start, silence.end)) {
                    const startX = timeToX(silence.start);
                    const endX = timeToX(silence.end);
                    const x = Math.max(0, startX);
                    const width = Math.min(waveformData.canvasWidth, endX) - x;
                    if (width > 0) {
                        ctx.fillRect(x, tracks.silences, width, trackHeight);
                        ctx.strokeRect(x, tracks.silences, width, trackHeight);
                    }
                }
            });
            
            // Draw pyannote (green boxes) in second track
            ctx.strokeStyle = 'green';
            ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
            waveformData.pyannote.forEach(item => {
                if (overlapsView(item.start, item.end)) {
                    const startX = timeToX(item.start);
                    const endX = timeToX(item.end);
                    const x = Math.max(0, startX);
                    const width = Math.min(waveformData.canvasWidth, endX) - x;
                    if (width > 0) {
                        ctx.fillRect(x, tracks.pyannote, width, trackHeight);
                        ctx.strokeRect(x, tracks.pyannote, width, trackHeight);
                    }
                }
            });
            
            // Draw segments (red boxes) in third track
            ctx.strokeStyle = 'red';
            ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
            ctx.font = '10px Arial';
            waveformData.segments.forEach((segment, index) => {
                if (overlapsView(segment.start, segment.end)) {
                    const startX = timeToX(segment.start);
                    const endX = timeToX(segment.end);
                    const x = Math.max(0, startX);
                    const width = Math.min(waveformData.canvasWidth, endX) - x;
                    if (width > 0) {
                        ctx.fillRect(x, tracks.segments, width, trackHeight);
                        ctx.strokeRect(x, tracks.segments, width, trackHeight);
                        
                        // Add segment number label if there's enough space
                        if (width > 20) {
                            ctx.fillStyle = 'red';
                            ctx.fillText(`S${index + 1}`, x + 2, tracks.segments + 12);
                            ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                        }
                    }
                }
            });
            
            // Draw subsegments (purple boxes) in fourth track
            ctx.strokeStyle = 'purple';
            ctx.fillStyle = 'rgba(128, 0, 128, 0.3)';
            ctx.font = '8px Arial';
            waveformData.segments.forEach((segment, segmentIndex) => {
                if (segment.subs && Array.isArray(segment.subs)) {
                    segment.subs.forEach((subsegment, subIndex) => {
                        if (overlapsView(subsegment.start, subsegment.end)) {
                            const startX = timeToX(subsegment.start);
                            const endX = timeToX(subsegment.end);
                            const x = Math.max(0, startX);
                            const width = Math.min(waveformData.canvasWidth, endX) - x;
                            if (width > 0) {
                                ctx.fillRect(x, tracks.subsegments, width, trackHeight);
                                ctx.strokeRect(x, tracks.subsegments, width, trackHeight);
                                
                                // Add subsegment label if there's enough space
                                if (width > 15) {
                                    ctx.fillStyle = 'purple';
                                    ctx.fillText(`${segmentIndex + 1}.${subIndex + 1}`, x + 2, tracks.subsegments + 10);
                                    ctx.fillStyle = 'rgba(128, 0, 128, 0.3)';
                                }
                            }
                        }
                    });
                }
            });
            
            // Draw transcriptions (orange boxes) in fourth track with punctuation-based border styles
            ctx.fillStyle = 'rgba(255, 165, 0, 0.3)';
            waveformData.transcriptions.forEach(trans => {
                if (overlapsView(trans.start, trans.end)) {
                    const startX = timeToX(trans.start);
                    const endX = timeToX(trans.end);
                    const x = Math.max(0, startX);
                    const width = Math.min(waveformData.canvasWidth, endX) - x;
                    if (width > 0) {
                        // Determine border color based on punctuation in text
                        let borderColor = 'orange'; // default
                        let borderWidth = 1;
                        
                        if (trans.text) {
                            if (trans.text.includes('?') || trans.text.includes('!') || trans.text.includes('.')) {
                                // Darker shade for sentence endings
                                borderColor = '#CC6600'; // darker orange
                                borderWidth = 2;
                            } else if (trans.text.includes(',')) {
                                // Black border for commas (better visibility)
                                borderColor = 'black';
                                borderWidth = 1;
                            }
                        }
                        
                        ctx.strokeStyle = borderColor;
                        ctx.lineWidth = borderWidth;
                        ctx.fillRect(x, tracks.transcriptions, width, trackHeight);
                        ctx.strokeRect(x, tracks.transcriptions, width, trackHeight);
                    }
                }
            });
        }

        function updateTimeDisplay() {
            const viewDuration = (waveformData.canvasWidth * waveformData.zoom) / 1000;
            const viewEnd = Math.min(waveformData.viewStart + viewDuration, waveformData.duration);
            
            document.getElementById('startTime').textContent = formatTime(waveformData.viewStart);
            document.getElementById('endTime').textContent = formatTime(waveformData.duration);
            document.getElementById('currentPosition').textContent = formatTime(waveformData.viewStart + viewDuration / 2);
            
            // Update slider position
            const maxViewStart = Math.max(0, waveformData.duration - viewDuration);
            const sliderValue = maxViewStart > 0 ? (waveformData.viewStart / maxViewStart) * 100 : 0;
            document.getElementById('timelineSlider').value = sliderValue;
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        async function refreshFile() {
            const project = currentProject;
            const filename = document.getElementById('dataFileSelect').value;
            const splitname = document.getElementById('dataSplitSelect').value;
            
            if (!project) {
                showMessage('Please select a project', true);
                return;
            }
            
            if (!filename) {
                showMessage('Please select a file', true);
                return;
            }

            if (!splitname) {
                showMessage('Please select a split', true);
                return;
            }

            try {
                const response = await fetch(`/api/projects/${project}/splits/${splitname}/refresh`, {
                    method: 'POST'
                });

                const result = await response.json();
                if (response.ok) {
                    showMessage(result.message);
                    if (result.processing_key) {
                        // Start monitoring the processing status
                        monitorProcessing(project, splitname);
                    }
                } else {
                    showMessage(result.error, true);
                }
            } catch (error) {
                showMessage('Error refreshing file: ' + error.message, true);
            }
        }

        async function loadProcessingStatus() {
            try {
                const response = await fetch('/api/processing/status');
                const statuses = await response.json();
                
                const statusDiv = document.getElementById('processingStatus');
                if (Object.keys(statuses).length === 0) {
                    statusDiv.innerHTML = '<p>No processing activities found.</p>';
                    return;
                }

                let html = '<table style="width: 100%; border-collapse: collapse;">';
                html += '<tr><th style="border: 1px solid #ddd; padding: 8px;">File</th><th style="border: 1px solid #ddd; padding: 8px;">Status</th><th style="border: 1px solid #ddd; padding: 8px;">Progress</th><th style="border: 1px solid #ddd; padding: 8px;">Message</th><th style="border: 1px solid #ddd; padding: 8px;">Started</th></tr>';
                
                for (const [key, status] of Object.entries(statuses)) {
                    const progressColor = status.status === 'completed' ? 'green' : 
                                        status.status === 'failed' ? 'red' : 'blue';
                    html += `<tr>
                        <td style="border: 1px solid #ddd; padding: 8px;">${key}</td>
                        <td style="border: 1px solid #ddd; padding: 8px; color: ${progressColor};">${status.status}</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">${status.progress}%</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">${status.message}</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">${new Date(status.started_at).toLocaleString()}</td>
                    </tr>`;
                }
                html += '</table>';
                
                statusDiv.innerHTML = html;
            } catch (error) {
                showMessage('Error loading processing status: ' + error.message, true);
            }
        }

        async function monitorProcessing(project, filename) {
            const checkStatus = async () => {
                try {
                    const response = await fetch(`/api/projects/${project}/processing/${filename}/status`);
                    const status = await response.json();
                    
                    if (response.ok) {
                        if (status.status === 'processing') {
                            showMessage(`Processing ${filename}: ${status.progress}% - ${status.message}`);
                            // Check again in 2 seconds
                            setTimeout(checkStatus, 2000);
                        } else if (status.status === 'completed') {
                            showMessage(`Processing completed for ${filename}!`);
                            loadProcessingStatus();
                        } else if (status.status === 'failed') {
                            showMessage(`Processing failed for ${filename}: ${status.message}`, true);
                            loadProcessingStatus();
                        }
                    }
                } catch (error) {
                    console.error('Error checking status:', error);
                }
            };
            
            checkStatus();
        }

        // Audio playback functions
        async function playAudio() {
            if (!waveformData.audioBuffer) {
                showMessage('No audio loaded', true);
                return;
            }

            try {
                await initializeAudioContext();
                
                if (audioSource) {
                    audioSource.stop();
                }

                // Create a new audio source
                audioSource = audioContext.createBufferSource();
                audioSource.buffer = waveformData.audioBuffer;
                
                // Connect to volume control
                const gainNode = audioContext.createGain();
                gainNode.gain.value = document.getElementById('volumeSlider').value / 100;
                audioSource.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Start playing from current position (audioStartOffset), not from view start
                audioSource.start(0, audioStartOffset);
                
                playStartTime = audioContext.currentTime;
                isPlaying = true;
                
                // Update button states - hide play, show pause
                document.getElementById('playBtn').style.display = 'none';
                document.getElementById('pauseBtn').style.display = 'inline-block';
                document.getElementById('pauseBtn').disabled = false;
                document.getElementById('stopBtn').disabled = false;
                
                // Start position animation
                startPositionTracking();
                
                // Handle audio end
                audioSource.onended = () => {
                    if (isPlaying) {
                        stopAudio();
                    }
                };
                
                showMessage('Audio playback started');
                
            } catch (error) {
                console.error('Error playing audio:', error);
                showMessage('Error starting playback: ' + error.message, true);
            }
        }

        function pauseAudio() {
            if (audioSource && isPlaying) {
                audioSource.stop();
                isPlaying = false;
                
                // Calculate current position for resume
                const elapsed = audioContext.currentTime - playStartTime;
                audioStartOffset += elapsed;
                
                // Update button states - show play, hide pause
                document.getElementById('playBtn').style.display = 'inline-block';
                document.getElementById('pauseBtn').style.display = 'none';
                
                stopPositionTracking();
                showMessage('Audio paused');
            }
        }

        function stopAudio() {
            if (audioSource) {
                audioSource.stop();
                audioSource = null;
            }
            
            isPlaying = false;
            audioStartOffset = waveformData.viewStart; // Reset to current view start
            
            // Reset button states - show play, hide pause
            document.getElementById('playBtn').style.display = 'inline-block';
            document.getElementById('pauseBtn').style.display = 'none';
            document.getElementById('stopBtn').disabled = true;
            
            stopPositionTracking();
            updateAudioTimeDisplay();
            drawWaveform(); // Redraw to remove position line
            showMessage('Audio stopped');
        }

        function seekToTime(timeInSeconds) {
            const wasPlaying = isPlaying;
            
            // Stop current audio without changing button states if we're going to resume
            if (isPlaying) {
                if (audioSource) {
                    audioSource.stop();
                    audioSource = null;
                }
                isPlaying = false; // Set this to false immediately to prevent state issues
                stopPositionTracking();
                // Don't call pauseAudio() as it changes button states
            }
            
            audioStartOffset = Math.max(0, Math.min(timeInSeconds, waveformData.duration));
            
            // Update view if seeking outside current view
            const viewDuration = (waveformData.canvasWidth * waveformData.zoom) / 1000;
            if (audioStartOffset < waveformData.viewStart || audioStartOffset > waveformData.viewStart + viewDuration) {
                waveformData.viewStart = Math.max(0, audioStartOffset - viewDuration / 2);
                updateTimeDisplay();
            }
            
            updateAudioTimeDisplay();
            drawWaveform();
            
            // Resume playback if it was playing before seeking
            if (wasPlaying) {
                // Wait a brief moment to ensure clean audio restart
                setTimeout(() => {
                    if (!isPlaying) { // Only restart if we're not already playing
                        playAudio();
                    }
                }, 20); // Increased timeout slightly for better reliability
            }
        }

        function getCurrentPlaybackTime() {
            if (!isPlaying || !audioContext) {
                return audioStartOffset;
            }
            
            const elapsed = audioContext.currentTime - playStartTime;
            return audioStartOffset + elapsed;
        }

        function startPositionTracking() {
            function updatePosition() {
                if (isPlaying) {
                    updateAudioTimeDisplay();
                    drawWaveform(); // Redraw to update position line
                    animationId = requestAnimationFrame(updatePosition);
                }
            }
            updatePosition();
        }

        function stopPositionTracking() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }

        function updateAudioTimeDisplay() {
            const currentTime = getCurrentPlaybackTime();
            const totalTime = waveformData.duration;
            
            document.getElementById('audioTime').textContent = 
                `${formatTime(currentTime)} / ${formatTime(totalTime)}`;
        }

        function displaySegmentsTable() {
            const dataViewer = document.getElementById('dataViewer');
            
            if (!waveformData.segments || waveformData.segments.length === 0) {
                dataViewer.innerHTML = '<p>No segments data available.</p>';
                return;
            }

            let html = `
                <h3>Segments (${waveformData.segments.length})</h3>
                <div style="margin: 10px 0;">
                    <button onclick="saveSegments()">Save Changes</button>
                    <button onclick="markAllGood()">Mark All Good</button>
                    <button onclick="markAllBad()">Mark All Bad</button>
                </div>
                <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                    <thead>
                        <tr style="background-color: #f0f0f0;">
                            <th style="border: 1px solid #ddd; padding: 8px;">ID</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Status</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Speaker</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Text</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Start (ms)</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">End (ms)</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Duration</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Confidence</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            waveformData.segments.forEach((segment, index) => {
                const startMs = Math.round(segment.start * 1000);
                const endMs = Math.round(segment.end * 1000);
                const duration = endMs - startMs;
                
                // Determine status based on confidence (default good if > 0.6)
                if (segment.status === undefined) {
                    segment.status = segment.confidence > 0.6 ? 'good' : 'bad';
                }
                
                const statusColor = segment.status === 'good' ? 'green' : 'red';
                const confidenceColor = segment.confidence > 0.6 ? 'green' : 'orange';
                
                html += `
                    <tr id="segment-row-${index}" style="background-color: ${segment.status === 'good' ? '#f0fff0' : '#fff0f0'};">
                        <td style="border: 1px solid #ddd; padding: 4px; text-align: center;">${segment.seg_idx || index + 1}</td>
                        <td style="border: 1px solid #ddd; padding: 4px; text-align: center;">
                            <select onchange="updateSegmentStatus(${index}, this.value)" style="color: ${statusColor};">
                                <option value="good" ${segment.status === 'good' ? 'selected' : ''}>Good</option>
                                <option value="bad" ${segment.status === 'bad' ? 'selected' : ''}>Bad</option>
                            </select>
                        </td>
                        <td style="border: 1px solid #ddd; padding: 4px;">
                            <input type="text" value="${segment.speaker || ''}" 
                                   onchange="updateSegmentField(${index}, 'speaker', this.value)"
                                   style="width: 80px; border: none; background: transparent;">
                        </td>
                        <td style="border: 1px solid #ddd; padding: 4px;">
                            <textarea onchange="updateSegmentField(${index}, 'text', this.value)"
                                      style="width: 200px; height: 40px; border: none; background: transparent; resize: vertical;">${segment.text || ''}</textarea>
                        </td>
                        <td style="border: 1px solid #ddd; padding: 4px;">
                            <input type="number" value="${startMs}" 
                                   onchange="updateSegmentTime(${index}, 'start', this.value)"
                                   style="width: 70px; border: none; background: transparent;">
                        </td>
                        <td style="border: 1px solid #ddd; padding: 4px;">
                            <input type="number" value="${endMs}" 
                                   onchange="updateSegmentTime(${index}, 'end', this.value)"
                                   style="width: 70px; border: none; background: transparent;">
                        </td>
                        <td style="border: 1px solid #ddd; padding: 4px; text-align: center;">${duration}ms</td>
                        <td style="border: 1px solid #ddd; padding: 4px; text-align: center; color: ${confidenceColor};">
                            ${(segment.confidence * 100).toFixed(1)}%
                        </td>
                        <td style="border: 1px solid #ddd; padding: 4px; text-align: center;">
                            <button onclick="playSegment(${index})" style="margin: 1px; padding: 2px 6px; font-size: 10px;"></button>
                            <button onclick="seekToSegment(${index})" style="margin: 1px; padding: 2px 6px; font-size: 10px;"></button>
                            <button onclick="deleteSegment(${index})" style="margin: 1px; padding: 2px 6px; font-size: 10px; color: red;"></button>
                        </td>
                    </tr>
                `;
            });

            html += `
                    </tbody>
                </table>
                <div style="margin: 10px 0; font-size: 12px; color: #666;">
                    <p><strong>Legend:</strong>  = Play segment,  = Seek to segment,  = Delete segment</p>
                    <p><strong>Status:</strong> Good segments will be included in final dataset, Bad segments will be excluded</p>
                </div>
            `;

            dataViewer.innerHTML = html;
        }

        function updateSegmentStatus(index, status) {
            waveformData.segments[index].status = status;
            
            // Update row background color
            const row = document.getElementById(`segment-row-${index}`);
            row.style.backgroundColor = status === 'good' ? '#f0fff0' : '#fff0f0';
            
            // Update select color
            const select = row.querySelector('select');
            select.style.color = status === 'good' ? 'green' : 'red';
        }

        function updateSegmentField(index, field, value) {
            waveformData.segments[index][field] = value;
        }

        function updateSegmentTime(index, timeType, valueMs) {
            const timeInSeconds = parseFloat(valueMs) / 1000;
            
            if (timeType === 'start') {
                waveformData.segments[index].start = timeInSeconds;
            } else if (timeType === 'end') {
                waveformData.segments[index].end = timeInSeconds;
            }
            
            // Update duration display
            const row = document.getElementById(`segment-row-${index}`);
            const startMs = Math.round(waveformData.segments[index].start * 1000);
            const endMs = Math.round(waveformData.segments[index].end * 1000);
            const duration = endMs - startMs;
            
            const durationCell = row.cells[6]; // Duration column
            durationCell.textContent = duration + 'ms';
            
            // Redraw waveform to show updated segment boundaries
            drawWaveform();
        }

        function playSegment(index) {
            const segment = waveformData.segments[index];
            
            // Stop current playback
            if (isPlaying) {
                stopAudio();
            }
            
            // Seek to segment start and play
            seekToTime(segment.start);
            
            // Start playback
            setTimeout(() => {
                playAudio();
                
                // Stop playback at segment end
                const segmentDuration = (segment.end - segment.start) * 1000; // Convert to ms
                setTimeout(() => {
                    if (isPlaying) {
                        pauseAudio();
                    }
                }, segmentDuration);
            }, 100); // Small delay to ensure seek completes
            
            showMessage(`Playing segment ${segment.seg_idx || index + 1}: "${segment.text}"`);
        }

        function seekToSegment(index) {
            const segment = waveformData.segments[index];
            seekToTime(segment.start);
            
            // Center the segment in view
            const viewDuration = (waveformData.canvasWidth * waveformData.zoom) / 1000;
            const segmentMiddle = (segment.start + segment.end) / 2;
            waveformData.viewStart = Math.max(0, segmentMiddle - viewDuration / 2);
            
            updateTimeDisplay();
            drawWaveform();
            
            showMessage(`Seeked to segment ${segment.seg_idx || index + 1}`);
        }

        function deleteSegment(index) {
            const segment = waveformData.segments[index];
            if (confirm(`Delete segment ${segment.seg_idx || index + 1}: "${segment.text}"?`)) {
                waveformData.segments.splice(index, 1);
                displaySegmentsTable();
                drawWaveform();
                showMessage(`Deleted segment ${segment.seg_idx || index + 1}`);
            }
        }

        function markAllGood() {
            waveformData.segments.forEach(segment => {
                segment.status = 'good';
            });
            displaySegmentsTable();
            showMessage('Marked all segments as good');
        }

        function markAllBad() {
            waveformData.segments.forEach(segment => {
                segment.status = 'bad';
            });
            displaySegmentsTable();
            showMessage('Marked all segments as bad');
        }

        async function saveSegments() {
            const project = currentProject;
            const filename = document.getElementById('dataFileSelect').value;
            const splitname = document.getElementById('dataSplitSelect').value;
            
            if (!project || !filename || !splitname) {
                showMessage('Please select project, file, and split', true);
                return;
            }

            try {
                // Convert segments back to the original format with times in milliseconds
                const segmentsData = {
                    segments: waveformData.segments.map((segment, index) => ({
                        seg_idx: segment.seg_idx || index + 1,
                        main: {
                            start_ms: Math.round(segment.start * 1000),
                            end_ms: Math.round(segment.end * 1000),
                            speaker: segment.speaker,
                            text: segment.text,
                            min_conf: segment.confidence
                        },
                        subs: segment.subs || [],
                        status: segment.status
                    }))
                };

                const response = await fetch(`/api/projects/${project}/splits/${filename}/${splitname}_segments.json`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(segmentsData)
                });

                if (response.ok) {
                    showMessage('Segments saved successfully!');
                } else {
                    const error = await response.json();
                    showMessage('Error saving segments: ' + (error.error || 'Unknown error'), true);
                }
            } catch (error) {
                showMessage('Error saving segments: ' + error.message, true);
            }
        }
    </script>
</body>
</html>